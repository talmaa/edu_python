_function.txt

문자열의 format() 함수
 - 숫자를 문자열로 변환하면서 몇가지 옵션을 추가해 주는 함수
 - 문법
"{}문자열".format(숫자) -> 중괄호에 지정한 숫자가 들어가면서 문자열로 변환됨
중괄호는 여러개를 사용할 수 있으며 반드시 중괄호의 개수만큼 숫자가 있어야 함
"{}{}...{}".format(data 1, data 2, ..., data n)
예) "{}세기는 {}년 부터 {}년 {}입니다.".format(20, 1901, 2000, "까지")
    -> "20세기는 1901년 부터 2000년 까지입니다."

대소문자 변경 함수
 - upper() : 문자열에서 소문자인 글자들을 대문자로 변경시킴
 - lower() : 문자열에서 대문자인 글자들을 소문자로 변경시킴
 - 두 함수 모두 원본을 바꾸는 것이 아닌 새로운 문자열로 리턴하는 함수

공백제거 함수 : trim 기능
 - 문자열의 양쪽 끝에 있는 공백을 제거하는 함수
 - strip() : 문자열의 양쪽 끝에 있는 문자열을 제거
    사용자가 입력하는 데이터에 대해 strip() 함수를 사용하는 경우가 많다
 - lstrip() : 문자열의 왼쪽 끝에 있는 문자열을 제거
 - rstrip() : 문자열의 오른쪽 끝에 있는 문자열을 제거
 - 세 함수 모두 원본을 바꾸는 것이 아닌 새로운 문자열로 리턴하는 함수

 문자열의 구성 검사 함수 : 리턴값이 논리값인 함수들로 조건으로 사용 가능
  - isalnum() : 문자열이 글자과 숫자로만 구성되었는지 여부를 리턴
  - isalpha() : 문자열이 글자로만 구성되었는지 여부를 리턴
  - isdecimal() : 문자열이 정수로만 구성되었는지 여부를 리턴
  - isdigit() : 문자열이 정수로 인식될 수 있는지 여부를 리턴
  - isspace() : 문자열이 공백으로만 구성되었는지 여부를 리턴
  - islower() : 문자열이 소문자로만 구성되었는지 여부를 리턴
  - isupper() : 문자열이 대문자로만 구성되었는지 여부를 리턴

문자열 찾기 함수
 - 문자열 내에서 특정 문자나 문자열을 찾아 인덱스를 리턴하는 함수
    특정 문자(열)의 존재 여부도 판단할 수 있음
 - find() : 지정한 문자(열)의 위치를 왼쪽 부터 찾기 시작하는 함수
 - rfind() : 지정한 문자(열)의 위치를 오른쪽 부터 찾기 시작하는 함수
 - 지정한 값을 찾지 못했을 경우 -1을 리턴

 in 연산자
  - 문자열 내에 특정 문자(열)을 포함하는지 여부를 리턴하는 키워드
  - 문법
"찾는 문자열" in "원본 문자열"

문자열 자르기 함수
 - 문자열을 특정 구분자를 이용하여 잘라내어 리스트로 리턴하는 함수
 - 문법
 문자열.split("구분자") : 문자열을 지정한 구분자를 기준으로 잘라 리스트로 리턴

 비교 연산자
  - 두 값을 서로 비교하여 그 결과값을 논리값(bool, boolean, 불, 부울 값)으로 리턴하는 연산자
  - ==(같다), !=(같지않다), >(크다), >=(크거나 같다), < (작다), <=(작거나 같다)
  - 피연산자는 숫자뿐만 아니라 문자열도 가능(문자열의 크기 비교도 가능)
  - 문자열 비교시 대문자가 소문자보다 작게 비교됨(ANSI 코드값으로 비교하기 때문)
  - 대소문자 상관 없이 비교하려면 upper()나 lower()함수르 이용하여 비교하려는 값 모두 대문자나
   소문자로 일괄적으로 만들어 놓고 비교해야 정확한 비교가 가능

논리 연산자
 - 여러 논리값(조건식)을 연산하여 하나의 논리값으로 만들어 주는 연산자
 - and : 논리 곱. 여러 조건들 중 하나라도 거짓이면 전체가 거짓이 되는 연산자
         참이 되려면 모든 조건이 참이여야 함
 - or : 논리합.  여러 조건들 중 하나라도 참이면 전체가 참이 되는 연산자
         거짓이 되려면 모든 조건이 거짓이여야 함
 - not : 부정.  참을 거짓으로 거짓을 참으로 전환하는 연산자

 리스트(list)
 - 여러개의 값(데이터)을 저장할 수 있는 자료형으로 대표적으로 리스트와 딕셔너리가 있음
 - 생성법
 리스트명 = [값1, 값2, ..., 값n]
  - 여러 값들을 쉼표로 구분하여 저장할 수 있음
  - 각 값들을 요소 또는 element라고 한다
  - 들어가는 값들은 같은 자료형일 필요는 없음(다른 리스트도 들어갈 수 있음)
  - 리스트의 값들은 인덱스를 통해 각각에 따로 접근할 수 있다
예) lst_a = [273, 32, 103, "문자열", True, False]
lst_a[0] -> 273,  lst_a[3] -> "문자열", lst_a[-1] -> False
 - 인덱스를 이용하면 리스트의 값들에 각각 접근할 수 있으며, 음수를 입력하면 뒤에서 부터 접근 가능
 - 리스트 내에 다른 리스트가 들어있을 경우 인덱스를 두번 입력하면 내부의 리스트에 접근 가능
 - 리스트에서 인덱스 번호를 넘어가게 입력하면  'list index out of range' 오류 발생

 리스트 연산자 : +, *, len() 함수
  - 문자열에서도 사용 가능한 연산자와 함수로 리스트의 연결(+), 반복(*), 길이를 구함
  lst1 = [1, 2, 3]
  lst2 = [4, 5, 6]
  lst1 + lst2 -> [1, 2, 3, 4, 5, 6] # 해당 리스트가 변하진 않음
  lst1 * 2 -> [1, 2, 3, 1, 2, 3] # 해당 리스트가 변하진 않음
   - '+'와 '*'를 이용하요 요소를 변경시킨 것을 유지하려면 다른 리스트에 담아야 함
    tmp1 = lst1 + lst2
    tmp2 = lst1 * 2
  len(lst1) -> 3
   - len()함수는 리스트 안에 있는 데이터의 개수로 리스트 마지막 인덱스 + 1의 값과 같음
     인덱스 번호 사용시 최대값 지정에 사용되기도 함

리스트에 요소 추가
 - append() 함수
   리스트의 가장 뒤에 새로운 요소를 추가하는 함수
   문법 : 리스트.append(추가할 요소)
   lst1.append(10) -> [1, 2, 3, 10]
 - insert() 함수
    리스트에서 원하는 위치에 새로운 요소를 끼워넣는 함수
    문법 : 리스트.insert(끼워넣을 위치, 끼워넣을 요소)
    lst1.insert(1, 44) -> [1, 44, 2, 3, 10]
    insert() 함수를 이용하여 새로운 데이터를 끼워넣으면 기존의 자리에 있던 데이터들은 뒤로 밀려난다
 - extend() 함수
    리스트의 가장 뒤에 리스트 형태로 여러 데이터를 추가하는 함수
    문법 : 리스트.extend(추가할 리스트)
    lst1.extend([11, 22, 33]) -> [1, 44, 2, 3, 10, 11, 22, 33]
    extend() 함수를 사용하면 해당 리스트의 요소가 바뀜
    리스트의 '+'는 해당 리스트를 변경하지는 않음
  - index() 함수
     파라미터로 지정한 데이터의 리스트내 위치 인덱스 번호를 리턴
     문법 : 리스트.index(찾을 데이터)

리스트 요소 삭제
 - del 명령어
    리스트에서 지정한 인덱스에 해당하는 데이터를 삭제
    문법 : del 리스트[인덱스]
    del lst1[2] -> [1, 44, 3, 10, 11, 22, 33]
    리스트에 없는 인덱스 번호를 사용하면 오류 발생

 - pop() 함수
    리스트에서 지정한 인덱스에 해당하는 데이터를 뽑아옴(원본에선 삭제)
    문법 : [변수 =] 리스트.pop([인덱스]) -> 인덱스를 생략하면 마지막 요소를 뽑아옴
    lst1.pop(2) -> 3을 추출(2번 인덱스 요소)
    lst1.pop() -> 33을 추출(마지막 요소)
    결과 -> [1, 44, 10, 11, 22]
    리스트에 없는 인덱스 번호를 사용하면 오류 발생

 - remove() 함수
    리스트에서 지정한 값을 삭제
    문법 : 리스트.remove(삭제할 값)
    lst1.remove(10) -> [1, 44, 11, 22]
    리스트에 없는 값을 사용하면 오류 발생
  
 - clear() 함수
    리스트의 내부의 모든 데이터를 삭제하는 함수
    lst1.clear() -> []

리스트 내부에 있는 데이터 검색 연산자
 - in 연산자
    리스트 내부에서 특정 데이터가 있는지 여부를 논리값으로 리턴하는 연산자
    문법 : 값 in 리스트
    lst = ["ab", "cd", "ef", "gh", "ij"]
    print("cd" in lst) -> True

 - not in 연산자와
    리스트 내부에서 특정 데이터가 없는지 여부를 논리값으로 리턴하는 연산자
    문법 : 값 not in 리스트
    "cd" not in lst -> False
    in 연산자를 사용한 후 not으로 전체를 감싼것과 동일함
    not("cd" in lst) -> False
딕셔너리(dictionary)
 - 리스트와 마찬가지로 여러개의 데이터를 저장하는 기능
 - 단, 리스트와 다르게 인덱스를 사용하지 않고, 키라는 일종의 이름을 사용하여 접근
 - 딕셔너리의 데이터는 키와 값을 쌍(pair)으로 이루어져 있음
 - 선언
딕셔너리 이름 = {키1:값1, 키2:값2, ..., 키n:값n}
-> {'키1':'aa', '키2':'값2','키3':'값2'}
 - 키는 중복되면 안되므로 동일한 키가 입력될 경우 기존의 키에 덮어쓰기 됨
 - 값은 중복되어도 괜찮으므로 그대로 저장됨
 - 딕셔너리에서 하나의 값만 추출할 경우 : dic["키2"] -> 값2
 - 리스트를 값으로 넣을 수도 있음
 예) dic2 = {"name":"홍길동", "job":"도둑", "address":["울릉도", "제주도", "함경도"]}
  print(dic2["address"]) -> ['울릉도', '제주도', '함경도']
  print(dic2["address"][1]) -> 제주도

딕셔너리에 데이터 추가
 - 딕셔너리에 새로운 데이터를 추가하려면 키와 값의 쌍으로 입력해야 함
   문법 : 딕셔너리[추가할 키] = 추가할 값
   dic2["age"] = 33
   # 추가한 값은 딕셔너리의 가장 뒤에 추가됨

   dic2["name"] = "전우치"
   기존의 존재하는 키와 동일한 키를 추가할 경우 기존의 키에 덮어쓰기가 이루어 짐

딕셔너리에서 값 삭제
 - del 명령을 이용하여 삭제할 키를입력하면 됨
 - 문법 : del 딕셔너리[삭제할 키]
 예) del dic2["job"]
    dic2에서 "job"이라는 키를 가진 데이터 삭제
    print(dic2)
    {'name': '전우치', 'address': ['울릉도', '제주도', '함경도'], 'age': 33}

    del dic2["job"]
    존재하지 않는 키를 삭제할 경우 KeyError 발생

 특정 키의 존재 여부를 검사
  - in 명령어
      리스트내 특정 값이 있는지 여부를 감사할 때 사용한 in명령은 딕셔너리에서도 사용 가능
      문법 : 키 in 딕셔너리 -> 키의 존재여부에 따라 논리값 리턴

  - get() 함수
      딕셔너리 내의 데이터를 추출하는 함수로 존재하지 않는 키를 사용해도 오류를 발생시키지 않음
      문법 : 딕셔너리.get(키) -> 존재하는 키면 키에 해당하는 값을, 존재하지 않으면 None을 리턴
    예) 
      # if dic2.get("address") is not None :
      if dic2.get("address") != None :
          print(dic2["address"])
      else : 
          print("존재하지 않는 키입니다.")

 제어문
  - 프로그램은 기본적으로 위에서 아래로, 왼쪽에서 오른쪽으로 실행이 되며, 그 순서를
    잠깐이나마 변경하여 원하는 방향으로 실행되게 하는 것이 흐름 제어문이라고 한다
  - 제어문은 분기문과 반복문으로 이루어져 있음

1. 분기문
 - 조건을 주어 조건이 참일 경우와 거짓을 경우 각각 다른 작업을 진행하게 하는 제어문
 - if문으로 모든 프로그래밍 언어에 동일하게 존재하는 대표적인 분기문임

if 조건식:  # 조건식 : 결과값이 논리값(True, False)으로 나오는 수식
  조건식이 참일경우 처리할 실행문(여러 줄일 수 있음)
  실행문은 반드시 들여쓰기 후 입력해야 함
[
elif 조건식2:
  조건식2이 참일경우 처리할 실행문
elif 조건식3:
  조건식3이 참일경우 처리할 실행문
...
]
[
else:
  조건식이 거짓일 경우 처리할 실행문(여러 줄일 수도 있음)
]

 - if문에서 else절을 사용하게 되면 무조건 실행문들 중 하나는 실행되게 된다
 - else절은 '아니면'이라는 조건이 되기 때문에 그 범위가 생각보다 넓다는 것을 유의해야 함
 - pass 키워드 : 내용 부분에 대한 코딩을 나중에 하겠다는 의미의 명령어
 - if문 안에서 다른 if문을 사용해도 됨(중첩 if문)
   안쪽 if문의 조건은 기본적으로 바깥족 if문의 조건을 만족한 상태에서 처리하게 된다

if 조건1 :
  if 조건1-1 : # 조건 1이 참인 상태에서 검사하게 됨
    실행문

2. 반복문(루프문)
  - 조건이 참인 동안 지정할 실행문(들)을 반복해서 실행하게 해주는 제어문

2-1. for문
  - 루프를 돌 횟수가 정해져 있는 경우 많이 사용하는 반복문
  - 문법
  1) 인덱스 사용시 유용한 방법
  for 변수 in range(횟수) :
    실행문(들)
  - 변수에 처음에 0으로 시작하여 지정한 횟수보다 작을 동안 1씩 증가하면서 루프를 돔
  예) for i in range(5) : # i의 값이 0부터 5가 될 때 까지 돌면서 실행문을 실행함
        print(i)    # 0, 1, 2, 3, 4

  - 변수에 들어가는 값을 0번 부터가 아닌 지정한 값으로 사용하려면 range() 함수를 이용
  예) for i in range(5, 10) :  i의 값이 5부터 10이 될 때 까지 돌면서 실행문을 실행함
        print(i)    # 5, 6, 7, 8, 9

  - 리스트의 각 데이터에 접근하여 출력
  예) 방법 1. 리스트의 각 데이터에 접근하여 출력하는 방법
  for i in range(len(lst)) : # lst 리스트이 모든 데이터를 차례대로 출력(for문 이용)
    print(lst[i])
    # ab cd ef gh ij

  - range() 함수
      매개변수의 개수에 따라 동작되는 방법이 달라지는 함수
      문법
      range(횟수) : 0부터 횟수 -1 까지 지정한 횟수를 루프를 돌림
      range(시작인덱스, 종료인덱스) : 시작인덱스 부터 종료인덱스 -1 까지 지정한 횟수를 루프를 돌림
        - 시작 인덱스 번호를 지정할 수 있음
      range(시작인덱스, 종료인덱스, 증감) : 시작인덱스 부터 종료인덱스 -1 까지 인덱스 '증감' 만큼 띄어서 루프를 돌림
        - 시작인덱스와 종료인덱스 외에 증감분을 지정할 수 있음

      예)
      lst = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k"]
      print("-----------------------")
      # 리스트 전체 출력 : index 0 ~ lst length -1
      for i in range(len(lst)) :
          print(lst[i])
          # a b c d e f g h i j k
      print("-----------------------")
      # 리스트 c부터 h까지 출력 : index 2 ~ lst length -3
      for i in range(2, len(lst) - 3) :
          print(lst[i])
          # c d e f g h


      print("-----------------------")
      # 리스트 a부터 2씩 증가하여 마지막까지 출력 : index 0, 2, 4, .. , lst length -1
      for i in range(0, len(lst), 2) :
          print(lst[i])
          # a c e g i k

      print("-----------------------")
      # 리스트 k부터 a까지 역순으로 출력
      for i in range(len(lst), 0, -1) :
          print(lst[i - 1])
          # k j i h g f e d c b a

      print("-----------------------")
      # 리스트 k부터 a까지 역순으로 출력(reversed 함수 사용)
      for i in reversed(range(len(lst))) :
          print(lst[i])
          # k j i h g f e d c b a

  예) 방법2. 리스트라는 객체와 함께 사용하는 방법
  for 변수 in 리스트 :
    실행문
  - 변수에  리스트의 데이터를 처음부터 끝까지 차례대로 담으면서 루프를 돔
  for tmp in lst : # lst 리스트이 모든 데이터를 차례대로 출력(for문 이용)
    print(tmp)
    # ab cd ef gh ij

  2-2. while 문
    - for문과 다르게 횟수를 직접 지정할 수는 업승나 조건이 참인 동안 루프를 돔
    - 루프를 도는 횟수가 정해져 있지 않은 경우 주로 while 문을 사용
    - 문법
    while 조건식 :
        실행문

    - break 키워드
        반복문 내에서 사용되는 키워드로 반복문을 강제로 빠져나올 때 사용함
        주로 무한루프에서 반복하는 탈출용으로 많이 사용됨

    - continue 키워드
        반복문에서 현재 실행을 멈추고 다시 조건식으로 이동하는 명령
        continue의 아래쪽은 실행하지 않고 다음 반복으로 넘어감

문자열, 리스트, 딕셔너리에 관련된 기본 함수들
  - min(), max(), sum() 함수
    리스트에서 사용하는 기본함수들로 최소값, 최대값, 합계를 구하는 함수
    문법 : min(리스트), max(리스트), sum(리스트)

  - reversed() 함수
    리스트를 거꾸로 뒤집어 리턴하는 함수
    문법 : reversed(리스트)
    iterator 타입으로 리턴되기 때문에 list로 변경하기 위해서는 list()함수 사용이 필요

  - enumerate() 함수
    리스트의 인덱스와 값을 출력시키는 함수
    문법 : enumerate(리스트)
    enumerate 타입으로 리턴되기 때문에 list로 변경하기 위해서는 list()함수 사용이 필요
  
  - items() 함수
    딕셔너리에서 사용하는 enumerate() 함수와 비슷한 기능으로 키와 값을 분리하여 사용
    문법 : 딕셔너리.items()

  - join() 함수
    문자열로 구성된 리스트를 특정 구분자와 결합하여 새로운 문자열 생성
    문법 : 구분자.join(문자열로 구성된 리스트)
    구분자를 빈 문자열로 하면 리스트의 값들로면 문자열이 생성