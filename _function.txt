_function.txt

문자열의 format() 함수
 - 숫자를 문자열로 변환하면서 몇가지 옵션을 추가해 주는 함수
 - 문법
"{}문자열".format(숫자) -> 중괄호에 지정한 숫자가 들어가면서 문자열로 변환됨
중괄호는 여러개를 사용할 수 있으며 반드시 중괄호의 개수만큼 숫자가 있어야 함
"{}{}...{}".format(data 1, data 2, ..., data n)
예) "{}세기는 {}년 부터 {}년 {}입니다.".format(20, 1901, 2000, "까지")
    -> "20세기는 1901년 부터 2000년 까지입니다."

대소문자 변경 함수
 - upper() : 문자열에서 소문자인 글자들을 대문자로 변경시킴
 - lower() : 문자열에서 대문자인 글자들을 소문자로 변경시킴
 - 두 함수 모두 원본을 바꾸는 것이 아닌 새로운 문자열로 리턴하는 함수

공백제거 함수 : trim 기능
 - 문자열의 양쪽 끝에 있는 공백을 제거하는 함수
 - strip() : 문자열의 양쪽 끝에 있는 문자열을 제거
    사용자가 입력하는 데이터에 대해 strip() 함수를 사용하는 경우가 많다
 - lstrip() : 문자열의 왼쪽 끝에 있는 문자열을 제거
 - rstrip() : 문자열의 오른쪽 끝에 있는 문자열을 제거
 - 세 함수 모두 원본을 바꾸는 것이 아닌 새로운 문자열로 리턴하는 함수

 문자열의 구성 검사 함수 : 리턴값이 논리값인 함수들로 조건으로 사용 가능
  - isalnum() : 문자열이 글자과 숫자로만 구성되었는지 여부를 리턴
  - isalpha() : 문자열이 글자로만 구성되었는지 여부를 리턴
  - isdecimal() : 문자열이 정수로만 구성되었는지 여부를 리턴
  - isdigit() : 문자열이 정수로 인식될 수 있는지 여부를 리턴
  - isspace() : 문자열이 공백으로만 구성되었는지 여부를 리턴
  - islower() : 문자열이 소문자로만 구성되었는지 여부를 리턴
  - isupper() : 문자열이 대문자로만 구성되었는지 여부를 리턴

문자열 찾기 함수
 - 문자열 내에서 특정 문자나 문자열을 찾아 인덱스를 리턴하는 함수
    특정 문자(열)의 존재 여부도 판단할 수 있음
 - find() : 지정한 문자(열)의 위치를 왼쪽 부터 찾기 시작하는 함수
 - rfind() : 지정한 문자(열)의 위치를 오른쪽 부터 찾기 시작하는 함수
 - 지정한 값을 찾지 못했을 경우 -1을 리턴

 in 연산자
  - 문자열 내에 특정 문자(열)을 포함하는지 여부를 리턴하는 키워드
  - 문법
"찾는 문자열" in "원본 문자열"

문자열 자르기 함수
 - 문자열을 특정 구분자를 이용하여 잘라내어 리스트로 리턴하는 함수
 - 문법
 문자열.split("구분자") : 문자열을 지정한 구분자를 기준으로 잘라 리스트로 리턴

 비교 연산자
  - 두 값을 서로 비교하여 그 결과값을 논리값(bool, boolean, 불, 부울 값)으로 리턴하는 연산자
  - ==(같다), !=(같지않다), >(크다), >=(크거나 같다), < (작다), <=(작거나 같다)
  - 피연산자는 숫자뿐만 아니라 문자열도 가능(문자열의 크기 비교도 가능)
  - 문자열 비교시 대문자가 소문자보다 작게 비교됨(ANSI 코드값으로 비교하기 때문)
  - 대소문자 상관 없이 비교하려면 upper()나 lower()함수르 이용하여 비교하려는 값 모두 대문자나
   소문자로 일괄적으로 만들어 놓고 비교해야 정확한 비교가 가능

논리 연산자
 - 여러 논리값(조건식)을 연산하여 하나의 논리값으로 만들어 주는 연산자
 - and : 논리 곱. 여러 조건들 중 하나라도 거짓이면 전체가 거짓이 되는 연산자
         참이 되려면 모든 조건이 참이여야 함
 - or : 논리합.  여러 조건들 중 하나라도 참이면 전체가 참이 되는 연산자
         거짓이 되려면 모든 조건이 거짓이여야 함
 - not : 부정.  참을 거짓으로 거짓을 참으로 전환하는 연산자

 리스트(list)
 - 여러개의 값(데이터)을 저장할 수 있는 자료형으로 대표적으로 리스트와 딕셔너리가 있음
 - 생성법
 리스트명 = [값1, 값2, ..., 값n]
  - 여러 값들을 쉼표로 구분하여 저장할 수 있음
  - 각 값들을 요소 또는 element라고 한다
  - 들어가는 값들은 같은 자료형일 필요는 없음(다른 리스트도 들어갈 수 있음)
  - 리스트의 값들은 인덱스를 통해 각각에 따로 접근할 수 있다
예) lst_a = [273, 32, 103, "문자열", True, False]
lst_a[0] -> 273,  lst_a[3] -> "문자열", lst_a[-1] -> False
 - 인덱스를 이용하면 리스트의 값들에 각각 접근할 수 있으며, 음수를 입력하면 뒤에서 부터 접근 가능
 - 리스트 내에 다른 리스트가 들어있을 경우 인덱스를 두번 입력하면 내부의 리스트에 접근 가능
 - 리스트에서 인덱스 번호를 넘어가게 입력하면  'list index out of range' 오류 발생

 리스트 연산자 : +, *, len() 함수
  - 문자열에서도 사용 가능한 연산자와 함수로 리스트의 연결(+), 반복(*), 길이를 구함
  lst1 = [1, 2, 3]
  lst2 = [4, 5, 6]
  lst1 + lst2 -> [1, 2, 3, 4, 5, 6] # 해당 리스트가 변하진 않음
  lst1 * 2 -> [1, 2, 3, 1, 2, 3] # 해당 리스트가 변하진 않음
   - '+'와 '*'를 이용하요 요소를 변경시킨 것을 유지하려면 다른 리스트에 담아야 함
    tmp1 = lst1 + lst2
    tmp2 = lst1 * 2
  len(lst1) -> 3
   - len()함수는 리스트 안에 있는 데이터의 개수로 리스트 마지막 인덱스 + 1의 값과 같음
     인덱스 번호 사용시 최대값 지정에 사용되기도 함

리스트에 요소 추가
 - append() 함수
   리스트의 가장 뒤에 새로운 요소를 추가하는 함수
   문법 : 리스트.append(추가할 요소)
   lst1.append(10) -> [1, 2, 3, 10]
 - insert() 함수
    리스트에서 원하는 위치에 새로운 요소를 끼워넣는 함수
    문법 : 리스트.insert(끼워넣을 위치, 끼워넣을 요소)
    lst1.insert(1, 44) -> [1, 44, 2, 3, 10]
    insert() 함수를 이용하여 새로운 데이터를 끼워넣으면 기존의 자리에 있던 데이터들은 뒤로 밀려난다
  - extend() 함수
    리스트의 가장 뒤에 리스트 형태로 여러 데이터를 추가하는 함수
    문법 : 리스트.extend(추가할 리스트)
    lst1.extend([11, 22, 33]) -> [1, 44, 2, 3, 10, 11, 22, 33]
    extend() 함수를 사용하면 해당 리스트의 요소가 바뀜
    리스트의 '+'는 해당 리스트를 변경하지는 않음

 제어문
  - 프로그램은 기본적으로 위에서 아래로, 왼쪽에서 오른쪽으로 실행이 되며, 그 순서를
    잠깐이나마 변경하여 원하는 방향으로 실행되게 하는 것이 흐름 제어문이라고 한다
  - 제어문은 분기문과 반복문으로 이루어져 있음

1. 분기문
 - 조건을 주어 조건이 참일 경우와 거짓을 경우 각각 다른 작업을 진행하게 하는 제어문
 - if문으로 모든 프로그래밍 언어에 동일하게 존재하는 대표적인 분기문임

if 조건식:  # 조건식 : 결과값이 논리값(True, False)으로 나오는 수식
  조건식이 참일경우 처리할 실행문(여러 줄일 수 있음)
  실행문은 반드시 들여쓰기 후 입력해야 함
[
elif 조건식2:
  조건식2이 참일경우 처리할 실행문
elif 조건식3:
  조건식3이 참일경우 처리할 실행문
...
]
[
else:
  조건식이 거짓일 경우 처리할 실행문(여러 줄일 수도 있음)
]

 - if문에서 else절을 사용하게 되면 무조건 실행문들 중 하나는 실행되게 된다
 - else절은 '아니면'이라는 조건이 되기 때문에 그 범위가 생각보다 넓다는 것을 유의해야 함
 - pass 키워드 : 내용 부분에 대한 코딩을 나중에 하겠다는 의미의 명령어
 - if문 안에서 다른 if문을 사용해도 됨(중첩 if문)
   안쪽 if문의 조건은 기본적으로 바깥족 if문의 조건을 만족한 상태에서 처리하게 된다

if 조건1 :
  if 조건1-1 : # 조건 1이 참인 상태에서 검사하게 됨
    실행문